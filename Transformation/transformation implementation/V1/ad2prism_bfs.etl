pre{
	var toBeVisitedNodes = new Sequence;
	var visitedNodes = new Sequence;
	//nodeModuleMap is a map containing many map
	var nodeModuleMap = new Map;
	//'maps' is a sequence containing all the maps, each map cantain only one element
	var maps = new Sequence;
	//modSeqs is a sequence of sequence, the atomic sequence contains the maps for the same module
	//the size of modSeqs is the same as the number of the modules created 
	var modSeqs = new Sequence;
	var dummyNodeModuleMap = new Map;
	var is_root = true;
}


rule activityToPrism
transform act : AD!Activity
to m : PRISM!Model
{

	m.modelType = PRISM!ModelType#DTMC;
 	
 	var toBeTerminated = mkBoolVarDecl(act, "to_be_terminated", "false");
 	m.globals.add(toBeTerminated);
 	
 	var INACTIVE = mkConst("INACTIVE", -1);
  	m.constants.add(INACTIVE);
 	

/*******************************************
// Pre-Processing activity diagram
*******************************************/
		

	//Initial nodes: for each initial node, every outgoing edge creates a new module
	var init_nodes= act.ownedNode.select(n|n.type().name="InitialNode").sortBy(c | c.name) ;
	for(inode in init_nodes){
		for(oe in getAllEdgesFromNode(act,inode)){
			var mod = mkModuleDef(mkModuleName(act,inode,oe), Sequence{}, Sequence{});
			m.modules.add(mod);
			if(is_root){
				mod.vars.add(mkVarDecl(mod, -1, null, "0"));
			} 
			//TO DO: is this else necessary for initial nodes????????????
			else {
				mod.vars.add(mkVarDecl(mod, -1, null, "INACTIVE"));
			}
			
			//add the initial node to the map
			nodeModuleMap.put(Tuple {nd = inode, edg = oe}, mod);
		    addMap(maps, Tuple {nd = inode, edg = oe}, mod);

		
			
			//add the next node to the initial node to the map
			nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
			addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
			
			
			toBeVisitedNodes.add(oe.target);
			
			
		}
		visitedNodes.add(inode);
	}
		
 	
 	
 	
 	//traverse all nodes in toBeVistedNodes (initial nodes not included)
	traverseNodes(m, act, true, INACTIVE, toBeTerminated);
	
	
	//Post-processing: Scan each Merge Node with a dummy module for the loop
	//TO DO: this is designed for loop, not implemented yet
	while(dummyNodeModuleMap.size()>0){
		var mp = dummyNodeModuleMap.removeAt(0);
		
		var node = mp.keySet().at(0).nd;
 		var ie = mp.keySet().at(0).edg;
	}
	
	
	
	//processing the nodeModuleMap as a sequence (modSeqs) of sequence(mdSeq)
 	for (md in m.modules){
 		var mdSeq = maps.select(m|m.values().at(0) = md);
 		modSeqs.add(mdSeq);
 		
 	}
 
 
 				
 	//Transformation: using modSeqs
 	//each modSeq corresponding to a module
 	var is_main = true; //only main module can set to_be_terminated as false
 	for(mdSeq in modSeqs){
 		
 		("is_main = " + is_main).println();
 		var i = 0; //the index of map in the sequence
 		var const_num = 0;  //the number of constant created = init value of the const
 		while(i<mdSeq.size()){ //processing each map in the sequence
 			var node = mdSeq.at(i).keySet().at(0).nd;
 			var ie = mdSeq.at(i).keySet().at(0).edg;
 			var mod = mdSeq.at(i).values().at(0);
			("mod= "+ mod.name).println();
			("node = "+node.name).println();
			("ie = "+ ie.name).println();
			if(node.instanceOf(InitialNode) ){
				//create the FIRST constant for the module
				//assign value of constant as 0, and update at the last
				var const = mkConst(mod.name, node.name, const_num);
				m.constants.add(const);
				const_num++;
				
				var const_nxt = mkConst(mod.name, mdSeq.at(i+1).keySet().at(0).nd.name, const_num);
				
				//create the FIRST command of the module
				mod.commands.add(mkCommand(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, const_nxt));
				delete const_nxt;
			} else if(node.instanceOf(OpaqueAction)){
				var const = mkConst(mod.name, node.name, const_num);
				m.constants.add(const);
				const_num++;
				
				for(oe in getAllEdgesFromNode(act,node)){
					var const_nxt = mkConst(mod.name, oe.target.name, const_num);
					mod.commands.add(mkCommand(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, const_nxt));
					delete const_nxt;
				}
			} else if(node.instanceOf(ForkNode)){
				var const = mkConst(mod.name, node.name, const_num);
				m.constants.add(const);
				const_num++;
				
				var firstOEdge = getAllEdgesFromNode(act,node).sortBy(c | c.name).at(0);
				var const_nxt = mkConst(mod.name, firstOEdge.target.name, const_num);
				
				mod.commands.add(mkCommandSyncAct(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, const_nxt));
				delete const_nxt;
			} else if(node.instanceOf(JoinNode)){
				var const = mkConst(mod.name, node.name, const_num);
				m.constants.add(const);
				const_num++;
				
				//TO DO: the following can be simplified using the merge node method as below in the comments
				var pathContinue = false;
				var oe = getAllEdgesFromNode(act, node).at(0);
				var furtherMod  = nodeModuleMap.get(nodeModuleMap.keySet.selectOne(t|(t.nd = oe.target) and (t.edg = oe)));
				if(furtherMod = mod){
					pathContinue = true;	
				}
				
			
					
				//if the next node of this join node is in this sequence AND join.oe = next.ie
				// it means that the path is proceeded through this join node in this sequence
				
				if(pathContinue){
					var const_nxt = mkConst(mod.name, oe.target.name, const_num+1);
				
					mod.commands.add(mkCommandSyncAct(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, const_nxt));
					delete const_nxt;
				} else {
					mod.commands.add(mkCommandSyncAct(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, INACTIVE));
				}
			} else if(node.instanceOf(DecisionNode)){
				var const = mkConst(mod.name, node.name, const_num);
				m.constants.add(const);
				const_num++;
				
				var branchesProbabilistic = IsProbabilistic(act,node);
				
			
				
				if(branchesProbabilistic){
				
					var updates = Set{};
					for(oe in getAllEdgesFromNode(act,node).sortBy(c | c.name)){
						var const_nxt = mkConst(mod.name, oe.target.name, const_num+1);
				
						var prob = getProb(oe);
						updates.add(mkUpdate(prob,mod.vars.at(0),const_nxt));
						delete const_nxt;
					}
					mod.commands.add(mkCommand(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, updates));
				} else{
					for(oe in getAllEdgesFromNode(act,node).sortBy(c | c.name)){
						var grd = getGuardVarExpr(oe, node, act, m);
						var const_nxt = mkConst(mod.name, oe.target.name, const_num+1);
					
						mod.commands.add(mkCommandforDecisionNdWithGrd(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, grd, const_nxt));
						delete const_nxt;
					}
				}
			} else if(node.instanceOf(MergeNode)){
				
				
				
				var oe = getAllEdgesFromNode(act, node).at(0);
				var furtherMod  = nodeModuleMap.get(nodeModuleMap.keySet.selectOne(t|(t.nd = oe.target) and (t.edg = oe)));
				
				if(furtherMod = mod){
					
					if(not m.constants.selectOne(n|n.name = mod.name+"::"+node.name).isDefined()){ //if is defined, then, a const has been created for this merge node, it means the mergenode has been processed, as all incoming edges are in the same module, so Merge node is to be processed only once
						
						var const = mkConst(mod.name, node.name, const_num);
						m.constants.add(const);
						const_num++;
						
						var const_nxt = mkConst(mod.name, oe.target.name, const_num+1);
					
						mod.commands.add(mkCommand(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, const_nxt));
						delete const_nxt;
					
					} else {
						"This is the second time to process M2, do nothing".println();
					}
					
				} else {
					var const = mkConst(mod.name, node.name, const_num);
					m.constants.add(const);
					const_num++;
					
					//action for merge need to be sync: DigitalCamera::M1::E6 --->  node.name+"::"+ie.name
					mod.commands.add(mkCommandSyncAct(act, mod, node.name+"::"+ie.name, mod.vars.at(0), const, toBeTerminated, INACTIVE));
				}
			} else if(node.instanceOf(FlowFinalNode)){
								
				var const = mkConst(mod.name, node.name, const_num);
				m.constants.add(const);
				const_num++;
								
				mod.commands.add(mkCommand(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, INACTIVE));
			} else if(node.instanceOf(ActivityFinalNode)){
								
				var const = mkConst(mod.name, node.name, const_num);
				m.constants.add(const);
				const_num++;
				
				var updates = Set{};
				updates.add(mkUpdate(mod.vars.at(0),INACTIVE));
				updates.add(mkUpdate(toBeTerminated,true));		
					
				mod.commands.add(mkCommand(act, mod, "", mod.vars.at(0), const, toBeTerminated, updates));
				
				
				
			}
		 	
 			i++;
 		}	
 	
 		var mod = mdSeq.at(0).values().at(0);
 		if(is_main  = false){
 			//add a sync command to end all the non-main module using action "terminate"
 			//e.g., [DigitalCamera::terminate] (DigitalCamera::to_be_terminated) -> (DigitalCamera::F1::E3::pc'=INACTIVE);
 			var updates = Set{};
			updates.add(mkUpdate(mod.vars.at(0),INACTIVE));
 			mod.commands.add(mkCommandSyncAct(act, mod, "terminate", toBeTerminated, updates));
 		}
 	
 	
 	
 	
 	
 		//is_main = true, means this module(mdSeq) is set as the main module, so other modules has is_main as false
 	 	else if(is_main = true){
 			//create a variable "terminated" in the main module only
			var terminated = mkBoolVarDecl(act, "terminated", "false");
			
			mod.vars.add(terminated);
					
			//create a termination command only for the main module
			mod.commands.add(mkCommand(act, mod, "terminate", mod.vars.at(0), toBeTerminated, terminated,  terminated, true));
				
			//create a command to set to_be_terminated = false only for main module
			var updates = Set{};
			updates.add(mkUpdate(mod.vars.at(0),INACTIVE));
			updates.add(mkUpdate(toBeTerminated,false));		
			mod.commands.add(mkCommand(act, mod, "", mod.vars.at(0), toBeTerminated, terminated, updates));
		 	
 			is_main = false;
 		}
 		
 			mod.vars.at(0).type.top = const_num-1;
 			//the number of maps processed in mdSeq may be larger than the constant/command generated
 			//so need to declare a var const_num apart from the map index 'i'
 	}			
 	
 	
 	
 
}

//IsProbabilistic(act,node)
//to return a bool value stating if the branches of decision node are probabilistic
operation IsProbabilistic(act: AD!Activity, node: AD!DecisionNode): Boolean {
	//assuming if one oe is Probabilistic, then all oes are Probabilistic
	// so we only check the first oe
	var oe = getAllEdgesFromNode(act, node).at(0);
	var isProb = false;
	if( oe.getAppliedStereotypes().size()>0){
		for(st in oe.getAppliedStereotypes()){
			if(oe.hasValue(st,"probability")){
				isProb = isProb or true;
			}
		}
	}
	return isProb;
}

// prob = getProb(oe);
//to return a probability value from the stereotype 
operation getProb(oe: AD!ControlFlow): Real {
	var prob : Real;
	if( oe.getAppliedStereotypes().size()>0){
		for(st in oe.getAppliedStereotypes()){
			if(oe.hasValue(st,"probability")){
				prob = oe.getValue(st,"probability");
			}
		}
	}
	return prob;
}



//grd = getGuard(oe);
//to return the guard of the edge (control flow, the outgoing edge of decision node) 
operation getGuardVarExpr(oe: AD!ControlFlow, dn: AD!DecisionNode,act: AD!Activity, m: PRISM!Model): PRISM!VarDecl{
	if(oe.`guard`.isDefined()){
		var grdVar = new PRISM!VarDecl;
		var grd = oe.`guard`.value;
		if(not (grd = "else")){
			grdVar = mkBoolVarDecl(act, grd.asString(), "false");
			m.globals.add(grdVar);
		}


		//var grd.asString() = true;
		
		if(grd = "else"){
			grdVar = mkBoolVarDecl(act,(dn.name+"::"+grd.asString()),"true");
			m.globals.add(grdVar);
									
		}
		
		return grdVar;
	} 		
}


operation addMap(maps: Sequence, tpl: Tuple, mod: PRISM!ModuleDef): Sequence {
	var map = new Map;
	map.put(tpl, mod);
	maps.add(map);
	
	return maps;
}

operation traverseNodes(m : PRISM!Model, act: AD!Activity, is_root: Boolean, INACTIVE: PRISM!Constant, toBeTerminated: PRISM!VarDecl){
	while(toBeVisitedNodes.notEmpty()){
		
		var node = toBeVisitedNodes.removeAt(0);
		
		if(node.instanceOf(OpaqueAction)){
		
			//find the module that stores the node
			//'get' method can only take one parameter, not a set
			var mod = nodeModuleMap.get(nodeModuleMap.keySet.selectOne(t|t.nd = node));
			for(oe in getAllEdgesFromNode(act,node)){
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
				
				toBeVisitedNodes.add(oe.target);
				
			}
			visitedNodes.add(node);
			
			
			
			
		} else if(node.instanceOf(ForkNode)){
			
			var mod = nodeModuleMap.get(nodeModuleMap.keySet.selectOne(t|t.nd = node));
			var isFirst = true;
			for(oe in getAllEdgesFromNode(act,node).sortBy(c | c.name)){
				if(isFirst){
					nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
					addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
					
					isFirst = false;
				} else {
					var newmod = mkModuleDef(mkModuleName(act,node,oe), Sequence{}, Sequence{});
					
					m.modules.add(newmod);
					
					var pc = mkVarDecl(newmod, -1, null, "INACTIVE");
					newmod.vars.add(pc);
					
					//create the FIRST constant for the module
					var const = mkConst(newmod.name, oe.target.name, 0);
					//m.constants.add(const);
					
					newmod.commands.add(mkCommandSyncAct(act, newmod, node.name, pc, INACTIVE, toBeTerminated, const));					
					nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, newmod);
					addMap(maps, Tuple {nd = oe.target, edg = oe}, newmod);
				
					delete const;
				}
				toBeVisitedNodes.add(oe.target);
				
			}
			visitedNodes.add(node);

			"".println();
			("toBeVisitedNodes: "+toBeVisitedNodes).println();
			
			"".println();
			("visitedNodes: "+visitedNodes).println();
			
			
		} else if(node.instanceOf(JoinNode)){
		
		//to check if the source node to the first edge to the join node has been processed
		// if yes, then path continues
		//else, do noting ,wait source node to the first edge to be processed
		//that is for join node, the path always continue for the first incoming edge
		//The FIRST is determined by the names of the edges using sortBy(c | c.name)
		
			var ie = getAllEdgesToNode(act, node).sortEdgeByName().at(0);
		
			var mod = nodeModuleMap.get(nodeModuleMap.keySet.selectOne(t|t.nd = ie.source));
			if(not (mod.isDefined())){//TO DO: this seems not possible
			
				toBeVisitedNodes.add(node);
			
			} else {
				var oe = getAllEdgesFromNode(act,node).at(0);
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
			
				toBeVisitedNodes.add(oe.target);
				
				visitedNodes.add(node);
				toBeVisitedNodes.remove(node);//TO DO: update algorithm in overleaf
			}
		
		
		
		
		} else if(node.instanceOf(DecisionNode)){
					
			var mod = nodeModuleMap.get(nodeModuleMap.keySet.selectOne(t|t.nd = node));
			for(oe in getAllEdgesFromNode(act,node).sortBy(c | c.name)){
				
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
				
				toBeVisitedNodes.add(oe.target);
			
			}
			visitedNodes.add(node);
			
			
			
		} else if(node.instanceOf(MergeNode)){
			
			var all_source_vistied = true; //this should be checked using nodeModuleMap, if the incoming edge exists in nodeModuleMap, then it is "visited"
			var new_module_needed = false;
			//var in_same_module = true;
			
			var ies = getAllEdgesToNode(act,node); 
			for(i in ies){
				
				
				
				if(nodeModuleMap.get(nodeModuleMap.keySet.selectOne(t|t.edg = i)).isDefined() ){
					all_source_vistied = all_source_vistied and true;
					}
				else {
					all_source_vistied = all_source_vistied and false;
					
				}
			}
			
			("all_source_vistied = " +all_source_vistied).println();
		
			
			
					
			//allocated_mods represents the existing modules that contain this merge node, 
			//but it is possible that at this moment, some incoming edges of this merge have not been added into the MAP
			var allocated_mods = new Set;
			for(k in nodeModuleMap.keySet()){
				if(k.nd = node){
				allocated_mods.add(nodeModuleMap.get(k));
				}
			}
			
		
			//"===========".println();
			//var allocated_mods = nodeModuleMap.get(nodeModuleMap.keySet.selectOne(t|t.nd = node));
		
			
			//the incoming edged of the node are from different moduels, a new module for this merge node is needed
			//it is possible that at this point some incoming edges have not be processed in any moduel yet 
			if(allocated_mods.size()>1){
				new_module_needed = true;
				//in_same_module = false;
				
			} else {
				//2 CASES:
				//a. in_same_module = true, i.e.,allocated_mods.size() = 1 and all_source_vistied
				//b. all_source_vistied = false, so can not decide if new module is needed (module.size = 1, but not all incoming edges are in this module, we need to wait either the moudle.size will increase, or all the incoming edges have been processed)
				new_module_needed = false;
			}
		
			
			
			if(new_module_needed ){
			
			"".println();
			"if(new_module_needed) is processed".println();
				var oe = getAllEdgesFromNode(act,node).at(0);
				var newmod = mkModuleDef(mkModuleName(act,node,oe), Sequence{}, Sequence{});
				("at line 585: A new module is created for the merge node: "+ node.name  + "modname: " +newmod.name).println();
				m.modules.add(newmod);
				var pc = mkVarDecl(newmod, -1, null, "INACTIVE");
				newmod.vars.add(pc);
				//create the FIRST constant for the module
				var const = mkConst(newmod.name, oe.target.name, 0);
				//m.constants.add(const);
				
				for(ie in getAllEdgesToNode(act,node)){
					newmod.commands.add(mkCommand(act, newmod, ie.name, pc, INACTIVE, toBeTerminated, const));					
				}
				delete const;
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, newmod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, newmod);
				"maps:".println();maps.println();
				toBeVisitedNodes.add(oe.target);
				
				
				toBeVisitedNodes.remove(node);//TO DO: update algorithm in overleaf
				visitedNodes.add(node);
				
				
				
				
				
			} else if(all_source_vistied and (not new_module_needed)){// continue the path within the same module
				
				var oe = getAllEdgesFromNode(act,node).at(0);
				var existingmod = allocated_mods.at(0);
				
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, existingmod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, existingmod);
				"maps:".println();maps.println();
				
				toBeVisitedNodes.add(oe.target);
				
				toBeVisitedNodes.remove(node);//TO DO: update algorithm in overleaf
				visitedNodes.add(node);
				
			
			
			} else {
				//all_source_vistied == false, new_module_needed == false
				if(toBeVisitedNodes.size()=0){
				"The ALGORITHM FOR DUMMY MODULE/ LOOP OF DECISION AND MERGE IS EXECUTED".println();
					var oe = getAllEdgesFromNode(act,node).at(0);
					var newmod = mkModuleDef(mkModuleName(act,node,oe), Sequence{}, Sequence{});
					("at line 631: A new module is created for the merge node for dummy? "+ node.name + "modname: " +newmod.name).println();
					//TO DO: I am not sure whether the follow line is needed
					//m.modules.add(newmod);
					
					var pc = mkVarDecl(newmod, -1, null, "INACTIVE");
					newmod.vars.add(pc);
					//create the FIRST constant for the module
					var const = mkConst(newmod.name, oe.target.name, 0);
					m.constants.add(const);
					for(ie in getAllEdgesToNode(act,node)){
						newmod.commands.add(mkCommand(act, newmod, ie.name, pc, INACTIVE, toBeTerminated, const));	
					}
					nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, newmod);
					addMap(maps, Tuple {nd = oe.target, edg = oe}, newmod);
					"maps:".println();maps.println();
					//???TO DO: only one key in tuple, what is the value of edg?
					dummyNodeModuleMap.put(Tuple{nd = node}, newmod);
					toBeVisitedNodes.add(oe.target);
					
					visitedNodes.add(node);
					
					
				} else {
					
					//TO DO
					// what is this situation?
					//the following line is commented out, is related to dummy, shall be added back
					//after the dummy section is complete
					
					toBeVisitedNodes.add(node);
					// visitedNodes.add(node);//?? TO DO
										
					
				}
			}
		
		

		} else if(node.instanceOf(FlowFinalNode)){
					
			visitedNodes.add(node);
		} else if(node.instanceOf(ActivityFinalNode)){
			
					
			visitedNodes.add(node);
		} else if(node.instanceOf(CallBehaviorAction)){
			traverseNodes(node.behavior, false);			
			var mod = nodeModuleMap.get(nodeModuleMap.keySet.selectOne(t|t.nd = node));
			for(oe in getAllEdgesFromNode(act,node)){
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
				"maps:".println();maps.println();
				toBeVisitedNodes.add(oe.target);				
			}
			visitedNodes.add(node);
		} 
	}
}

//this operation has two parameter, for INACTIVE
operation mkConst(cname : String, value : Integer) : PRISM!Constant {
	var const = new PRISM!Constant;   	
	const.name = cname;
	cname.println();
	const.type = new PRISM!IntType;	
	//false is the default value of type.nat, means int
	// true means nat
	const.type.nat = false;
	const.value = new PRISM!IntLitExpr;
	const.value.value = value;
	const.println();
		const.value.println();
	return const;
}	

//this operation has three parameters, for constants of each module
operation mkConst(mod_name: String, node_name : String, value : Integer) : PRISM!Constant {
	var const = new PRISM!Constant;   	
	const.name = mod_name + "::" + node_name;
	
	const.type = new PRISM!IntType;	
	//false is the default value of type.nat, means int
	// true means nat
	const.type.nat = false;
	const.value = new PRISM!IntLitExpr;
	const.value.value = value;
	return const;
}	


//mkCommand(act, mod, "terminate", mod.vars.at(0), toBeTerminated, terminated,terminated, true)
//used for termination in main module: to set terminated = true
//e.g., [DigitalCamera::terminate] (DigitalCamera::to_be_terminated) & (!DigitalCamera::terminated)->(DigitalCamera::terminated'=true);
operation mkCommand(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!VarDecl,  //first guard
	g2: PRISM!VarDecl,   //second guard
	update_var: PRISM!VarDecl, //update var
	update_value: Boolean  //update value
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(act,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuardFor2VarWithRightNeg(g1, g2);
	//TO DO
	cmd.updates.add(mkUpdate(update_var,update_value));
	return cmd;

}



//mkCommand(act, mod, "", mod.vars.at(0), toBeTerminated, terminated,  toBeTerminated, false, mod.vars.at(0), INACTIVE);
//used for the command in main module: to set to_be_terminated = false
//e.g.,[](DigitalCamera::terminated)&(DigitalCamera::to_be_terminated) ->(DigitalCamera::to_be_terminated'=false)& DigitalCamera::I0::E0::pc'=INACTIVE);
operation mkCommand(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!VarDecl,  //first guard
	g2: PRISM!VarDecl,   //second guard
	update_var: PRISM!VarDecl, //update var_1
	update_value: Boolean,  //update value_1
	update_var_2: PRISM!VarDecl, //update var_2
	update_value_2: PRISM!Constant  //update value_2
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(act,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuardForTwoVar(g1, g2);
	
	cmd.updates.add(mkUpdate(update_var,update_value));
	cmd.updates.add(mkUpdate(update_var_2,update_value_2));
	
	return cmd;

}



operation mkCommand(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!VarDecl,  //first guard
	g2: PRISM!VarDecl,   //second guard
	updates: Set
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(act,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuardForTwoVar(g1, g2);
	
	cmd.updates = updates;
	
	return cmd;

}


//the action is used for synchronization, the action method 'mkAction' has two parameter: ACT and NODE, e.g., [digitalcamera::F1] 
operation mkCommandSyncAct(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!Constant,  //first guard
	g2: PRISM!VarDecl,   //second guard
	const: PRISM!Constant  //update 
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(act,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuard(pc, g1, g2);
	//TO DO
	cmd.updates.add(mkUpdate(pc,const));
	return cmd;

}


//e.g., [DigitalCamera::terminate] (DigitalCamera::to_be_terminated) -> (DigitalCamera::F1::E3::pc'=INACTIVE);
//mkCommandSyncAct(act, mod, "terminate", toBeTerminated, updates)
//has ONLY ONE GUARD: to_be_terminated
operation mkCommandSyncAct(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	g: PRISM!VarDecl,   // guard= toBeTerminated
	updates: Set  //updates
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(act,node_or_edg_name); 
	}
	cmd.grd = mkGuard(g);
	//TO DO
	cmd.updates = updates;
	return cmd;

}
//the action method 'mkAction' has 2 parameters: MODULE and NODE, e.g., [digitalcamera::I0::E0::TurnOn] 
operation mkCommand(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!Constant,  //first guard
	g2: PRISM!VarDecl,   //second guard
	const: PRISM!Constant  //update 
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(module,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuard(pc, g1, g2);
	//TO DO
	cmd.updates.add(mkUpdate(pc,const));
	return cmd;

}



//the action method 'mkAction' has 2 parameters: MODULE and NODE, e.g., [digitalcamera::I0::E0::TurnOn] 
operation mkCommand(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc = mod.vars.at(0)
	g1: PRISM!Constant,  //first guard
	g2: PRISM!VarDecl,   //second guard
	updates: Set  //set of update
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(module,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuard(pc, g1, g2);
	
	cmd.updates = updates;
	return cmd;

}



//for Decision node with guard, without probability
//mkCommandforDecisionNdWithGrd(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, grd, const_nxt)
//mkCommand(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, grd, const_nxt)
//grd = edge.guard
//the action method 'mkAction' has 2 parameters: MODULE and NODE, e.g., [digitalcamera::I0::E0::TurnOn] 
operation mkCommandforDecisionNdWithGrd(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!Constant,  //first guard
	g2: PRISM!VarDecl,   //second guard = not to_be_terminated
	edge_grd:  PRISM!VarDecl, //3rd guard = edge guard
	const: PRISM!Constant  //update 
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(module,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuardForThreeVar(pc, g1, g2, edge_grd);
	//TO DO
	cmd.updates.add(mkUpdate(pc,const));
	return cmd;

}















//update with probability
operation mkUpdate (
	prob: Real,
	pc: PRISM!VarDecl, 
	const: PRISM!Constant): PRISM!Update {
	
	var update = new PRISM!Update;
	var probExpr = new PRISM!DoubleLitExpr;
	probExpr.value = prob.asDouble();
	update.probability = probExpr;
	
	update.assigns.add(mkAssignment(pc,const));	
	
	return update;

}


//no probability involved
//e.g.,(DigitalCamera::I0::E0::pc'=INACTIVE)
//e.g., (DigitalCamera::F1::E3::pc'=DigitalCamera::F1::E3::DetLight)
operation mkUpdate (
	pc: PRISM!VarDecl, 
	const: PRISM!Constant): PRISM!Update {
	
	var update = new PRISM!Update;
	//update.probability = 1;
	
	update.assigns.add(mkAssignment(pc,const));	
	
	return update;

}

//for main module termination command
//(DigitalCamera::terminated'=true)
//to assign a bool to a var
operation mkUpdate (
	update_var: PRISM!VarDecl, 
	update_value: Boolean
	): PRISM!Update {
	
	var update = new PRISM!Update;
	//update.probability = 1;
	
	update.assigns.add(mkAssignment(update_var, update_value));	
	
	return update;

}

//for main module command
//(DigitalCamera::I0::E0::pc'=INACTIVE)
//to assign a const to a var
operation mkUpdate (
	update_var: PRISM!VarDecl, 
	update_value: PRISM!Constant
	): PRISM!Update {
	
	var update = new PRISM!Update;
	//update.probability = 1;
	
	update.assigns.add(mkAssignment(update_var, update_value));	
	
	return update;

}

//to assign a bool to a var
operation mkAssignment(
	update_var: PRISM!VarDecl, 
	update_value: Boolean
	) : PRISM!Assignment {
	
	var assign = new PRISM!Assignment;
	assign.variable = update_var.name;
	assign.value = new PRISM!BoolLitExpr;
	assign.value.value = update_value;
		
	return assign;
}



//to assign a const to a var
operation mkAssignment(
	pc: PRISM!VarDecl, 
	const: PRISM!Constant) : PRISM!Assignment {
	
	var assign = new PRISM!Assignment;
	assign.variable = pc.name;
	assign.value = new PRISM!VarExpr;
	assign.value.name = const.name;
		
	return assign;
}




//value_expr = mkNotBoolExpr(getAllEdgesFromNode(act,dn).excluding(oe).at(0).`guard`.value);
operation mkNotBoolExpr(grd_name: String): PRISM!NotBoolExpr{
 	var notExpr = new PRISM!NotBoolExpr;
	notExpr.value = new PRISM!VarExpr;
	notExpr.value.name = grd_name;
	
	return notExpr;

}










//left: pc == g1
//right: ! g2
//TO DO: how to code optimization to remove notBoolExpr in the operation, and show it as a paramter
 
operation mkAndBoolGuard(
	pc: PRISM!VarDecl, 
	g1 : PRISM!Constant, 
	g2 : PRISM!VarDecl) : PRISM!BoolExpr {
	
	var grd = new PRISM!AndBoolExpr; 
	
	grd.left = new PRISM!EqBoolExpr;
	grd.left.left = new PRISM!VarExpr;	
	grd.left.left.name = pc.name;
	grd.left.right = new PRISM!VarExpr;
	grd.left.right.name = g1.name;
		
	grd.right = new PRISM!NotBoolExpr;
	grd.right.value = new PRISM!VarExpr;
	grd.right.value.name = g2.name;
	
	return grd;
}

//left = varDecl of Boolean type, right = varDecl of Boolean type
//e.g., (DigitalCamera::to_be_terminated) & (!DigitalCamera::terminated)
operation mkAndBoolGuardFor2VarWithRightNeg(
	g1 : PRISM!VarDecl, 
	g2 : PRISM!VarDecl) : PRISM!BoolExpr {
	
	var grd = new PRISM!AndBoolExpr; 
	
	grd.left = new PRISM!VarExpr;
	grd.left.name = g1.name;
		
	grd.right = new PRISM!NotBoolExpr;
	grd.right.value = new PRISM!VarExpr;
	grd.right.value.name = g2.name;

	
	return grd;
}






//left = varDecl of Boolean type, right = varDecl of Boolean type
//e.g., (DigitalCamera::to_be_terminated) & (DigitalCamera::terminated)
operation mkAndBoolGuardForTwoVar(
	g1 : PRISM!VarDecl, 
	g2 : PRISM!VarDecl) : PRISM!BoolExpr {
	
	var grd = new PRISM!AndBoolExpr; 
	
	grd.left = new PRISM!VarExpr;
	grd.left.name = g1.name;
		
	grd.right = new PRISM!VarExpr;
	grd.right.name = g2.name;

	
	return grd;
}

//to create the guard for Decision Node with guard, 
//[Digital_Camera::F1::E4::D3]   (pc = D3)  &  (!to_be_terminated) & charged      ->     pc' = M2
// g3 = charged
//charged is a global var
operation mkAndBoolGuardForThreeVar(
	pc: PRISM!VarDecl, 
	g1 : PRISM!Constant,
	g2 : PRISM!VarDecl,
	g3 : PRISM!VarDecl
	) : PRISM!BoolExpr {
	
	var grd = new PRISM!AndBoolExpr; 
	
	grd.left = new PRISM!EqBoolExpr;
	grd.left.left = new PRISM!VarExpr;	
	grd.left.left.name = pc.name;
	grd.left.right = new PRISM!VarExpr;
	grd.left.right.name = g1.name;
		
			
	grd.right = new PRISM!AndBoolExpr; 
	grd.right.left = new PRISM!NotBoolExpr;
	grd.right.left.value = new PRISM!VarExpr;
	grd.right.left.value.name = g2.name;
	
	
	grd.right.right = new PRISM!VarExpr;
	grd.right.right.name = g3.name;

	
	return grd;
}


//mkGuard(g): to convert a var into a guard (boolExpr)
//e.g., in this command: [DigitalCamera::terminate](DigitalCamera::to_be_terminated) -> (DigitalCamera::F1::E3::pc'=INACTIVE);
operation mkGuard(g:PRISM!VarDecl) : PRISM!BoolExpr {
	
	var grd = new PRISM!VarExpr; 
	grd.name = g.name;
	
	return grd;
}









operation mkAction(act: AD!Activity, name: String) : PRISM!Action
{
	var action = new PRISM!Action;
	action.name = act.name + "::" + name;
	return action;
}

operation mkAction(mod: PRISM!ModuleDef, name: String ) : PRISM!Action
{
	var action = new PRISM!Action;
	action.name = mod.name + "::" + name;
	return action;
}

operation mkBoolVarDecl(
	act: AD!Activity,
	name: String,
	init_value: String) : PRISM!VarDecl
{
	var v = new PRISM!VarDecl;
	v.name = act.name + "::" + name;
	v.type = new PRISM!BoolType;
	v.init = mkVarExpr(init_value);
	return v;
}

operation mkVarDecl(
	module: PRISM!ModuleDef,
	range_bottom: Integer,
	range_top: Integer,
	initial: String
	) : PRISM!VarDecl
{
	var v = new PRISM!VarDecl;
	v.name = module.name + "::pc";
	v.type = new PRISM!RangeType;
	v.type.bottom = range_bottom;
	//TO DO
	if(range_top=null){
		v.type.top = null;
	} else v.type.top = range_top;
	v.init = mkVarExpr(initial);
	return v;
}
	
@pre name.length() > 0
operation mkVarExpr(name: String) : PRISM!VarExpr
{
	var v = new PRISM!VarExpr;
	v.name = name;
	return v;
}	



// getAllEdgesFromNode return a set of outgoing edges of a node
operation getAllEdgesFromNode(act: AD!Activity,node: AD!ControlNode ): Set {
	return act.edge.select(e|e.source = node);
}
 	
 
operation getAllEdgesFromNode(act: AD!Activity,node: AD!Action ): Set {
	return act.edge.select(e|e.source = node);
}

operation getAllEdgesToNode(act: AD!Activity,node: AD!ControlNode ): Set {
	return act.edge.select(e|e.target = node);
}

operation getAllEdgesToNode(act: AD!Activity,node: AD!Action ): Set {
	return act.edge.select(e|e.target = node);
}

operation mkModuleName(act: AD!Activity, node: AD!ControlNode, oe: AD!ActivityEdge): String {
	
	var name: String;
	name = act.name + "::" + node.name + "::" + oe.name;
	return name;
	}	
 	
operation mkModuleDef(mod_name: String, vs: Sequence, cmds: Sequence): PRISM!ModuleDef {
	
	var mod = new PRISM!ModuleDef;
	mod.name = mod_name;
	mod.vars = vs;
	mod.commands = cmds;
	return mod;
	}	
 	
 	
//getAllEdgesToNode(act, node).sortBy(c | c.name)
operation Set sortEdgeByName(): Sequence{
	var inter_Set = Set{};
	for(edg in self){
		edg.name.subString(1);
		var tpl = Tuple{edge = edg, name = edg.name.subString(1).asInteger()};
		inter_Set.add(tpl);
	}
	
	var output = Sequence{};
	for(t in inter_Set.sortBy(t|t.name)){
		output.add(t.edge);
	}
	return output;
}