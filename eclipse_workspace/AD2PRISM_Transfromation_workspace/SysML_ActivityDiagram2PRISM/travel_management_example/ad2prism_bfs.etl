
import "prism.eol";
import "ad.eol";

pre{
	var toBeVisitedNodes = new Sequence;
	var visitedNodes = new Sequence;
	//nodeModuleMap is a map containing many map
	var nodeModuleMap = new Map;
	//'maps' is a sequence containing all the maps, each map cantain only one element
	var maps = new Sequence;
	//modSeqs is a sequence of sequence, the atomic sequence contains the maps for the same module
	//the size of modSeqs is the same as the number of the modules created 
	var modSeqs = new Sequence;
	var dummyNodeModuleSeq = new Sequence;
	var is_root = true;
	
	var progress_made = new Map;

}


rule activityToPrism
transform act : AD!Activity
to m : PRISM!Model
{

	m.modelType = PRISM!ModelType#DTMC;
 	
 	//var toBeTerminated = mkBoolVarDecl(act, "to_be_terminated", "false");
 	//m.globals.add(toBeTerminated);
 	//to_be_terminated is defined as a formula instead of a global variable
 	var toBeTerminated = new PRISM!Formula;
 	
 	toBeTerminated.name = act.name + "::to_be_terminated";
 	// toBeTerminated.expr is set as false when defined, and will be updated when the local toBeTerminated is defined
 	toBeTerminated.expr = mkBoolLitExpr(false);
 	m.formulas.add(toBeTerminated);
 	toBeTerminated.expr.println();
 	("toBeTerminated.expr.type: "+toBeTerminated.expr.type()).println();
 	//an indicator if the formula toBeTerminated has ever been updated
	var toBeTerminatedIsUpdated = false;
		
	var toBeFailed = new PRISM!Formula;
 	toBeFailed.name = act.name + "::to_be_failed";
 	toBeFailed.expr = mkBoolLitExpr(false);
 	m.formulas.add(toBeFailed);
 	var toBeFailedIsUpdated = false;
			
 	var INACTIVE = mkConst("INACTIVE", -1);
  	m.constants.add(INACTIVE);

/*******************************************
// Pre-Processing activity diagram
*******************************************/
		

	//Initial nodes: for each initial node, every outgoing edge creates a new module
	var init_nodes= act.ownedNode.select(n|n.type().name="InitialNode").sortBy(c | c.name) ;
	for(inode in init_nodes){
		for(oe in getAllEdgesFromNode(act,inode)){
			var mod = mkModuleDef(mkModuleName(act,inode,oe), Sequence{}, Sequence{});
			m.modules.add(mod);
			if(is_root){
				mod.vars.add(mkVarDecl(mod, -1, null, "0"));
			} 
			//TO DO: is this else necessary for initial nodes????????????
			else {
				mod.vars.add(mkVarDecl(mod, -1, null, "INACTIVE"));
			}
			
			//add the initial node to the map
			nodeModuleMap.put(Tuple {nd = inode, edg = oe}, mod);
		    addMap(maps, Tuple {nd = inode, edg = oe}, mod);

			"maps:".println();maps.println();
			
			//add the next node to the initial node to the map
			nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
			addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
			"maps:".println();maps.println();
			
			toBeVisitedNodes.add(oe.target);
			"".println();
			("node "+ oe.target.name + "is added to toBeVisitedNodes at line 67").println();
		}
		visitedNodes.add(inode);
	}
		
 	
 	
 	
 	//traverse all nodes in toBeVistedNodes (initial nodes not included)
	traverseNodes(m, act, true, INACTIVE, toBeTerminated, toBeTerminatedIsUpdated);

	
	
/*************************************************************************
//Post-processing: Scan each Merge Node with a dummy module for the loop
**************************************************************************/

	while(dummyNodeModuleSeq.size()>0){
		("this is the post-processing section at line 78.  dummyNodeModuleSeq.size = "+ dummyNodeModuleSeq.size).println();
		"dummyNodeModuleSeq.size()>0, LOOP is involved, the dummy module shall be processed as follow:".println();
		var mp = dummyNodeModuleSeq.removeAt(0);
		"mp:".println();
		mp.println();
		var node = mp.keySet().at(0);
 		var dummymod = mp.values().at(0);
 		
 		if(node.instanceOf(MergeNode)){
 			var setMods = Set{};
 			for (mp in maps.select(mp|mp.keySet().at(0).nd = node)){
 				setMods.add(mp.values().at(0));
 			}
 			
 			if(setMods.size() > 2) {
 				"setMods.size() > 2, do nothing".println();
 				//do nothing, keep using the dummy module
 			} else if(setMods.size() = 2 and not setMods.includes(dummymod)){
 			
 				"setMods.size()  = 2 and not setMods.includes(dummymod), do nothing".println();
 				// do nothing, keep using the dummy module
 			} else if(setMods.size() = 2 and setMods.includes(dummymod)) { //setMods.includes(dummymod) MEANS that the loop and the merge outgoning path are in the same module, so all incoming should be in the same module
 			//therefore there should be only one module for all these maps (the maps in the normal module and the dummymodule), we need to change the module name of the dummynodemodule into the module name of the module created in the normal procedure
 				("setMods.size() = 2, it includes: " + setMods).println();
 				var rightmod = new PRISM!ModuleDef;
 				"setMods.size()  = 2 and setMods.includes(dummymod), replace dummy with rightmod".println();
 				// in this case, we use another module for the outgoing edge, and need to replace all occurrences of dummymod in nodeModuleMap by another moduel
 				if(setMods.at(0) = dummymod){//the first module is the dummy module, so we use the second module as the correct module name
 					rightmod  = setMods.at(1);
 				} else { //the second module is the dummy module, so we use the first module as the correct module name
 					rightmod  = setMods.at(0);
 				} 
 				
 				
 				
 				
 				//replace dummy module with rightmod module in the related maps
 				var i=1;
 				var toBeReplaced = maps.select(mp|mp.values().at(0) = dummymod);
 				for(mp in toBeReplaced){
 					addMap(maps, mp.keySet().at(0), rightmod);
 					//maps.add(mp.keySet().at(0), rightmod);
 					maps.remove(mp);
 					("replaced " + i + " times").println();
 					i++;
 				}
 				("Currently, m.modules =  " +m.modules).println();
 				delete dummymod;
 				("after delet dummymod at line 144, Currently, m.modules =  " +m.modules).println();
 			} else if(setMods.size() = 1 and not setMods.includes(dummymod)){
 				"setMods.size()  =1 and not setMods.includes(dummymod), replace dummy with rightmod".println();
 				var rightmod  = setMods.at(0);
 								
 				
 				var toBeReplaced = maps.select(mp|mp.values().at(0) = dummymod);
 				for(mp in toBeReplaced){
 					addMap(maps, mp.keySet().at(0), rightmod);
 					maps.remove(mp);
 				}
 				("Currently, m.modules =  " +m.modules).println();
 				delete dummymod;
 				("after delet dummymod at line 142, Currently, m.modules =  " +m.modules).println();
 			} else {
 				//Error("Logic error: not possible!")
 			}
 			
 		}
	}
	
	
/*************************************************************************
Processing the nodeModuleMap as a sequence (modSeqs) of sequence(mdSeq)
*************************************************************************/

 	for (md in m.modules){
 		var mdSeq = maps.select(m|m.values().at(0) = md);
 		modSeqs.add(mdSeq);
 		mdSeq.println();
 	}
 	("maps.size: " + maps.size()).println();
 	for(mp in maps){
 		mp.println();
 	}
 				
 				
/********************************************
Transformation: using modSeqs
each modSeq sequence corresponding to a module
*********************************************/

 	var is_main = true; 
 	
 	for(mdSeq in modSeqs){
 		"".println();
 		"START PRINT".println();
 		("is_main = " + is_main).println();
 		var i = 0; //the index of map in the sequence
 		var const_num = 0;  //the number of constant created = init value of the const
 		
 				
 		//TO DO: CHANGE TO OPERATION: updateToBeTerminated
 		/***************************************************************/
 			var mod = mdSeq.at(0).values().at(0);
 			var mod_toBeTerminated = new PRISM!VarDecl;
 			if(hasAF(mdSeq) or hasReAnnoNode(mdSeq)){
 				//hasAF, then need to create the local toBeTerminated, e.g., DigitalCamera::M1::to_be_terminated
 				//this var MUST be defined BEFORE the module start as it may be used at any point of the command creation
				mod_toBeTerminated = mkBoolVarDecl(mod.name+"::to_be_terminated", false);
				
				("mod_toBeTerminated is created as "+mod_toBeTerminated).println();
			    mod.vars.add(mod_toBeTerminated);
				
				//update the expression of the fomula 'toBeTerminated.expr' using the local 'toBeTerminated'
				if(toBeTerminatedIsUpdated){
					toBeTerminated.expr = mkOrBoolExpr(toBeTerminated.expr, mod_toBeTerminated);
				} else {
					toBeTerminated.expr = new PRISM!VarExpr;
					toBeTerminated.expr = mkVarExpr(mod_toBeTerminated.name);
					toBeTerminatedIsUpdated = true;
				} 
			}
			
			var mod_toBeFailed;
			if(hasReAnnoNode(mdSeq)){
				mod_toBeFailed = mkBoolVarDecl(mod.name + "::to_be_failed", false);
				mod.vars.add(mod_toBeFailed);
				if(toBeFailedIsUpdated){
					toBeFailed.expr = mkOrBoolExpr(toBeFailed.expr, mod_toBeFailed);
				} else {
					toBeFailed.expr = new PRISM!VarExpr;
					toBeFailed.expr = mkVarExpr(mod_toBeFailed.name);
					toBeFailedIsUpdated = true;
				} 
			}
			
			
			/***************************************************************/
 		
 		
 		/***************************************************************/
 		//process each element (the map) in the sequence mdSeq
 		while(i<mdSeq.size()){ 
 			var node = mdSeq.at(i).keySet().at(0).nd;
 			var ie = mdSeq.at(i).keySet().at(0).edg;
 			//var mod = mdSeq.at(i).values().at(0);
			("mod= "+ mod.name).println();
			("node = "+node.name).println();
			("ie = "+ ie.name).println();
			if(node.instanceOf(InitialNode) ){
				//TO DO: can intial node have multiple outgoing?
				
				//create the FIRST constant for the module
				//assign value of constant as 0, and update at the last
				var const = mkConst((mod.name + "::" + node.name), const_num);
				m.constants.add(const);
				const_num++;
				
				var const_nxt = mkConst(mod.name + "::" + mdSeq.at(i+1).keySet().at(0).nd.name, const_num);
				
				//create the FIRST command of the module
				//first to create action, guard, updates RESPECTIVELY
				//then the command 
				var action = mkAction(mod, node.name);
					
				var grd = new PRISM!AndBoolExpr;
				grd = mkAndBoolExpr(mkEqBoolExpr(mod.vars.at(0), const), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
				
				var updates = Set{};
				if(mdSeq.at(i+1).keySet().at(0).nd.instanceOf(ActivityFinalNode)){//the next node is final activity node, so the command.updates has an extra assignment: local_to_be_terminated = true e.g., (DigitalCamera::M1::to_be_terminated'=true)
				// e.g., in the command: [DigitalCamera::M1::TurnOff] (DigitalCamera::M1::pc=DigitalCamera::M1::TurnOff) &  (!DigitalCamera::to_be_terminated) -> (DigitalCamera::M1::pc'=DigitalCamera::M1::ActivityFinal) &         (DigitalCamera::M1::to_be_terminated'=true);
					updates.add(mkUpdate(mod.vars.at(0),const_nxt, mod_toBeTerminated, true)); 
				} else {
					updates.add(mkUpdate(mod.vars.at(0),const_nxt));	
				}
					
					
				mod.commands.add(mkCommand(action, grd, updates));
								
				delete const_nxt;
			} else if(node.instanceOf(OpaqueAction)){
				var const = mkConst(mod.name + "::" + node.name, const_num);
				m.constants.add(const);
				const_num++;
				
				for(oe in getAllEdgesFromNode(act,node)){
					var const_nxt = mkConst(mod.name + "::" + oe.target.name, const_num);
					var action = mkAction(mod, node.name);
					var grd = new PRISM!AndBoolExpr;
					grd = mkAndBoolExpr(mkEqBoolExpr(mod.vars.at(0), const), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
					
					
					if(nodeAnnotated(node, "reliability")){
						var prob = getPRValue(node);
						
						var updates = Set{};
						if(oe.target.instanceOf(ActivityFinalNode)){
							updates.add(mkProbUpdate(prob, mod.vars.at(0),const_nxt, mod_toBeTerminated, true)); 
							updates.add(mkProbUpdate(mkMinusExpr(mkDoubleLitExpr(1.0),prob), mod.vars.at(0),INACTIVE, mod_toBeFailed, true, mod_toBeTerminated, true));   
						} else {
							"this else branch is executed".println();
							updates.add(mkProbUpdate(prob, mod.vars.at(0),const_nxt));
							updates.add(mkProbUpdate(mkMinusExpr(mkDoubleLitExpr(1.0),prob), mod.vars.at(0),INACTIVE, mod_toBeFailed, true, mod_toBeTerminated, true));		
						}
					mod.commands.add(mkCommand(action, grd, updates));
					} else{//the node is not annotated with probability or reliability
					
					
					var updates = Set{};
					if(oe.target.instanceOf(ActivityFinalNode)){
						updates.add(mkUpdate(mod.vars.at(0),const_nxt, mod_toBeTerminated, true)); 
					} else {
						updates.add(mkUpdate(mod.vars.at(0),const_nxt));	
					}
					mod.commands.add(mkCommand(action, grd, updates));
				
				}
				
					//mod.commands.add(mkCommand(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, const_nxt));
					delete const_nxt;
					
					/******************************************
					create reward for node.outgoingEdge
					******************************************/
					checkAndMkEdgeReward(oe, mod, node, action, const, m, act);
					
				}
				
				
				/******************************************
				create reward for the action
				******************************************/
				var r_node;
				if(nodeAnnotated(node, "rewards")){
				
					var rwds = getRewards(node);// rewds is a set
					
					/*
					for(rw in rwds){
						("reward.type = " + rw.type()).println();
						("reward.name = " + rw.name).println();
						("reward.value = " + rw.value).println();
						//("reward.value.value = " + rw.value.value).println();
						("getRewardValue(rwd) = " + getRewardValue(rw)).println();
					}*/
					for (rwd in rwds){
						var rwgrd = mkEqBoolExpr(mod.vars.at(0), const);
						var rwvalue = getRewardValue(rwd);
						var rwname = act.name + "::" + rwd.name;
						r_node = mkNodeReward(rwname, rwgrd, rwvalue);//node reward does not need action, so 3 parameters
						("reward r_node = " + r_node).println();
						var rewardIsDefined = false;
						for(rw in m.rewards){
							if(rw.name = r_node.name){
								rewardIsDefined = true;
							}
						}
						if(rewardIsDefined){
							("r_node:"+ r_node.name +"has been defined, only add the reward item into the existing reward").println();
							var rw = m.rewards.selectOne(reward|reward.name = r_node.name);
							rw.rewards.add(mkNodeRewardItem(rwgrd, rwvalue));
							delete r_node;
						} else {
							m.rewards.add(r_node);
						}
					
					
					}
				
					
				}
				
			
				
				
				

				
			} else if(node.instanceOf(ForkNode)){
				var const = mkConst(mod.name + "::" + node.name, const_num);
				m.constants.add(const);
				const_num++;
				
				//the next node of this fork node must be the target node of the 1st outgoing edge, in fact is should be the same as mdSeq.at(i+1).keySet().at(0).nd
				var firstOEdge = getAllEdgesFromNode(act,node).sortEdgeByName().at(0);
				var const_nxt = mkConst(mod.name + "::" + firstOEdge.target.name, const_num);


				var action = mkSyncAction(act, node.name);
					
				var grd = new PRISM!AndBoolExpr;
				grd = mkAndBoolExpr(mkEqBoolExpr(mod.vars.at(0), const), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
					
				var updates = Set{};
				if(firstOEdge.target.instanceOf(ActivityFinalNode)){
					updates.add(mkUpdate(mod.vars.at(0),const_nxt, mod_toBeTerminated, true)); 
				} else {
					updates.add(mkUpdate(mod.vars.at(0),const_nxt));	
				}
					
					
				mod.commands.add(mkCommand(action, grd, updates));
				delete const_nxt;
			} else if(node.instanceOf(JoinNode)){
				var const = mkConst(mod.name + "::" + node.name, const_num);
				m.constants.add(const);
				const_num++;
				
				//only the first incoming edge of the join node can continue the path
				if(ie = getAllEdgesToNode(act,node).sortEdgeByName().at(0)) {
					var oe = getAllEdgesFromNode(act,node).at(0);
					var const_nxt = mkConst(mod.name + "::" + oe.target.name, const_num+1);
					
					var action = mkSyncAction(act, node.name);
					
					var grd = new PRISM!AndBoolExpr;
					grd = mkAndBoolExpr(mkEqBoolExpr(mod.vars.at(0), const), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
					
					var updates = Set{};
					if(oe.target.instanceOf(ActivityFinalNode)){
						updates.add(mkUpdate(mod.vars.at(0),const_nxt, mod_toBeTerminated, true)); 
					} else {
						updates.add(mkUpdate(mod.vars.at(0),const_nxt));	
					}
					
					mod.commands.add(mkCommand(action, grd, updates));
					delete const_nxt;
				} else {//otherwise the path discontinue: INACTIVE
					
					var action = mkSyncAction(act, node.name);
					
					var grd = new PRISM!AndBoolExpr;
					grd = mkAndBoolExpr(mkEqBoolExpr(mod.vars.at(0), const), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
					
					var updates = Set{};
					updates.add(mkUpdate(mod.vars.at(0), INACTIVE));	
										
					mod.commands.add(mkCommand(action, grd, updates));
										
				}
			} else if(node.instanceOf(DecisionNode)){
				var const = mkConst(mod.name + "::" + node.name, const_num);
				m.constants.add(const);
				const_num++;
				
				
				
				
				var branchesProbabilistic = IsProbabilistic(act,node);
				("branchesProbabilistic" + branchesProbabilistic).println();
								
				if(branchesProbabilistic){
					
					var action = mkAction(mod, node.name);
					("THIS DECISION NODE "+node.name + " IS TO BE PROCESSED").println();
					var grd = new PRISM!AndBoolExpr;
					grd = mkAndBoolExpr(mkEqBoolExpr(mod.vars.at(0), const), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
					var updates = Set{};
					for(oe in getAllEdgesFromNode(act,node).sortEdgeByName()){
						var const_nxt = mkConst(mod.name + "::" + oe.target.name, const_num+1);
						
						
						if(oe.target.instanceOf(ActivityFinalNode)){
							var prob = getProb(oe,m,mod);
							updates.add(mkUpdate(prob,mod.vars.at(0),const_nxt, mod_toBeTerminated, true));
						} else {
							var prob = getProb(oe,m,mod);
							updates.add(mkProbUpdate(prob,mod.vars.at(0),const_nxt));
						}
						delete const_nxt;
					}
					mod.commands.add(mkCommand(action, grd, updates));
				} else{//generate multiple commands
				
					for(oe in getAllEdgesFromNode(act,node).sortEdgeByName()){
						
						var action = mkAction(mod, node.name);
						
						
						("the oe to be processed is "+ oe.name).println();
						var decision_edge_grd_expr = getEdgeGuardVarExpr(oe, node, act, m);
						("for the decision node " + node.name + " it's edge guard is  " + decision_edge_grd_expr).println();
						("the action is "+ action ).println();
						var grd = new PRISM!AndBoolExpr;
						grd = mkAndBoolExpr( mkAndBoolExpr(mkEqBoolExpr(mod.vars.at(0), const), mkNotBoolExpr(mkVarExpr(toBeTerminated.name))), decision_edge_grd_expr) ;
						var const_nxt = mkConst(mod.name + "::" + oe.target.name, const_num+1);
						var updates = Set{};
						if(oe.target.instanceOf(ActivityFinalNode)){
							updates.add(mkUpdate(mod.vars.at(0),const_nxt, mod_toBeTerminated, true)); 
						} else {
							updates.add(mkUpdate(mod.vars.at(0),const_nxt));	
						}
										
						mod.commands.add(mkCommand(action, grd, updates));
						//("mkCommand(action, grd, updates)'s action is :" +mkCommand(action, grd, updates).action).println();
						delete const_nxt;
					}
				}
			} else if(node.instanceOf(MergeNode)){
							
				
				var oe = getAllEdgesFromNode(act, node).at(0);
				
				//furtherMod is the module that contains the target of mergenode.oe, so this should be searched in the entire collection of 'maps'
				var furtherMod = maps.selectOne(mp|mp.keySet().at(0) = Tuple{nd = oe.target, edg = oe}).values().at(0);
				//var furtherMod = maps.selectOne(m|m.values().at(0) = keySet().selectOne)
				if(furtherMod = mod){
					"for this merge node, furtherMod = mod".println();
					if(not m.constants.selectOne(n|n.name = mod.name+"::"+node.name).isDefined()){ //if is defined, then, a const has been created for this merge node, it means the mergenode has been processed, as all incoming edges are in the same module, so Merge node is to be processed only once
						
						var const = mkConst(mod.name + "::" + node.name, const_num);
						m.constants.add(const);
						const_num++;
						
						var const_nxt = mkConst(mod.name + "::" + oe.target.name, const_num+1);
						
						
						var action = mkAction(mod, node.name);
					
						var grd = new PRISM!AndBoolExpr;
						grd = mkAndBoolExpr(mkEqBoolExpr(mod.vars.at(0), const), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
					
						var updates = Set{};
						if(oe.target.instanceOf(ActivityFinalNode)){
							updates.add(mkUpdate(mod.vars.at(0),const_nxt, mod_toBeTerminated, true)); 
						} else {
							updates.add(mkUpdate(mod.vars.at(0),const_nxt));	
						}
						
						mod.commands.add(mkCommand(action, grd, updates));
						
						delete const_nxt;
						("this is the first time to process this merge node: "+ node.name).println();
					} else {
						("This is the second time to process this merge node: "+ node.name + " so do nothing.").println();
					}
					
				} else {
				//furtherMod != mod, this path discontinues: pc' = INACTIVE
				"for this merge node, furtherMod != mod".println();
				("furtherMod = "+ furtherMod).println();
				("mod = "+ mod).println();
				
					var const = mkConst(mod.name + "::" + node.name, const_num);
					m.constants.add(const);
					const_num++;
					
					//action for merge need to be sync: DigitalCamera::M1::E6 --->  node.name+"::"+ie.name
					
					
					
					var action = mkSyncAction(act, node.name+"::"+ie.name);
					
					var grd = new PRISM!AndBoolExpr;
					grd = mkAndBoolExpr(mkEqBoolExpr(mod.vars.at(0), const), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
					
					var updates = Set{};
					updates.add(mkUpdate(mod.vars.at(0), INACTIVE));	
										
					mod.commands.add(mkCommand(action, grd, updates));
				}
			} else if(node.instanceOf(FlowFinalNode)){
								
				var const = mkConst(mod.name + "::" + node.name, const_num);
				m.constants.add(const);
				const_num++;
				
				
				
				var action = mkAction(mod, node.name);
					
				var grd = new PRISM!AndBoolExpr;
				grd = mkAndBoolExpr(mkEqBoolExpr(mod.vars.at(0), const), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
					
				var updates = Set{};
				updates.add(mkUpdate(mod.vars.at(0), INACTIVE));	
										
				mod.commands.add(mkCommand(action, grd, updates));
								
			} else if(node.instanceOf(ActivityFinalNode)){
				if(not m.constants.selectOne(n|n.name = mod.name+"::"+node.name).isDefined()){ //if is defined, then, a const has been created for this merge node, it means the mergenode has been processed, as all incoming edges are in the same module, so Merge node is to be processed only once
						
				var const = mkConst(mod.name + "::" + node.name, const_num);
				m.constants.add(const);
				const_num++;
				
				var action = mkSyncAction(act, "terminate");		
				
				if(not is_main){// this AF node is not in the maim module, there should be terminate command for both this module and the main module
				var grd = new PRISM!VarExpr;
				grd = mkVarExpr(toBeTerminated.name);	
					
				//to creat terminate command, to set local to_be_terminated as false, and the module as INACTIVE
				//e.g., [DigitalCamera::terminate] (DigitalCamera::to_be_terminated) ->(DigitalCamera::M1::pc'=INACTIVE) & (DigitalCamera::M1::to_be_terminated'=false)
				var updates = Set{};
				updates.add(mkUpdate(mod.vars.at(0), INACTIVE, mod_toBeTerminated, false));		
					
				mod.commands.add(mkCommand(action, grd, updates));
				} else {//// this AF node is in the maim module, the terminate command for both this module and the main module shall be combined into one
				//e.g., in Dice example
				//[Six_dice_terminate] Six_dice_to_be_terminated &(! (Six_dice_terminated)) -> (Six_dice_I0_E0_pc'=INACTIVE)&(Six_dice_I0_E0_to_be_terminated'=false)&(Six_dice_terminated'=true);
				//we create this combined command after finishing the while loop	
				
				}
				
				}
				
				
				//mod.commands.add(mkCommand(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, INACTIVE));
			}
		 	
 			i++;
 		}	
 	
 		var mod = mdSeq.at(0).values().at(0);
 		
 		
 		
 		
 		//if not hasAF, also not a main module, then it has a normal terminate command
 		//e.g.,  [DigitalCamera::terminate]	(DigitalCamera::to_be_terminated) ->(DigitalCamera::M3::pc'=INACTIVE);
 		if(is_main  = false){
 			if(not hasAF(mdSeq)){
 				//add a sync command to end all the non-main module using action "terminate"
 				var action = mkSyncAction(act, "terminate");		
				var grd = new PRISM!VarExpr;
				grd = mkVarExpr(toBeTerminated.name);
 				var updates = Set{};
				updates.add(mkUpdate(mod.vars.at(0), INACTIVE));
				
				
				mod.commands.add(mkCommand(action, grd, updates));
				
				
 			} 
 		}
 	
 	
 	
 	
 	
 		//is_main = true, means this module(mdSeq) is set as the main module, so other modules has is_main as false
 	 	else if(is_main = true){
 	 		//create a variable "terminated" in the main module only
			var terminated = mkBoolVarDecl(act.name + "::terminated", false);
			mod.vars.add(terminated);
			
 	 		if(not hasAF(mdSeq)){
 	 			
			//create a termination command only for the main module
			//e.g.,  [DigitalCamera::terminate]  (DigitalCamera::to_be_terminated) &         (!DigitalCamera::terminated) ->   (DigitalCamera::I0::E0::pc'=INACTIVE)&       (DigitalCamera::terminated'=true);
			
			var action = mkSyncAction(act, "terminate");		
			var grd = new PRISM!AndBoolExpr;
			grd = mkAndBoolExpr(mkVarExpr(toBeTerminated.name), mkNotBoolExpr(mkVarExpr(terminated.name)));
 			var updates = Set{};
			updates.add(mkUpdate(mod.vars.at(0), INACTIVE,terminated, true));
				
			mod.commands.add(mkCommand(action, grd, updates));
			} else {// this AF node IS IN the maim module, the terminate command for both this module and the main module shall be combined into one
				//e.g., in Dice example
				//[Six_dice_terminate] Six_dice_to_be_terminated &(! (Six_dice_terminated)) -> (Six_dice_I0_E0_pc'=INACTIVE)&(Six_dice_I0_E0_to_be_terminated'=false)&(Six_dice_terminated'=true);
				
				var action = mkSyncAction(act, "terminate");		
				var grd = new PRISM!AndBoolExpr;
				grd = mkAndBoolExpr(mkVarExpr(toBeTerminated.name), mkNotBoolExpr(mkVarExpr(terminated.name)));
 				var updates = Set{};
				updates.add(mkUpdate(mod.vars.at(0), INACTIVE,terminated, true, mod_toBeTerminated, false));
				
				mod.commands.add(mkCommand(action, grd, updates));
			
			}
			
				
			//the following is abandoned as activityfinal is modified
			//create a command to set to_be_terminated = false only for main module
			/*
			var updates = Set{};
			updates.add(mkUpdate(mod.vars.at(0), INACTIVE,toBeTerminated,false));		
			mod.commands.add(mkCommand(act, mod, "", mod.vars.at(0), toBeTerminated, terminated, updates));
		 	*/
 			is_main = false;
 		}
 		
 			mod.vars.at(0).type.top = const_num-1;
 			//the number of maps processed in mdSeq may be larger than the constant/command generated
 			//so need to declare a var const_num apart from the map index 'i'
 	}			
 	
 	if(not toBeFailedIsUpdated ){
 		delete toBeFailed;
 	}









/*****************************************
generate parameters
******************************************/
("AD!Parameter.allInstances().size: "+AD!Parameter.allInstances().size()).println();
for (p in AD!Parameter.allInstances()){
	("[Parameter]: ").println();
	p.name.println();
	p.println();
	p.type().println();
	if(not p.qualifiedName.startsWith("SysML")){//to filter out the embedded parameter for sysml
		if(p.`default`.isDefined()){
			m.constants.add(mkConst(p.name, p.`default`));
		} else{
			m.constants.add(mkConst(p.name, null));
		}
	}

	
}




	
}





operation traverseNodes(
	m : PRISM!Model, 
	act: AD!Activity, 
	is_root: Boolean, 
	INACTIVE: PRISM!Constant, 
	toBeTerminated: PRISM!Formula,
	toBeTerminatedIsUpdated: Boolean
	){
	while(toBeVisitedNodes.notEmpty()){
		"".println();
		"toBeVisitedNodes.at(0):".println();
		toBeVisitedNodes.at(0).name.println();
		var node = toBeVisitedNodes.removeAt(0);
		
		if(node.instanceOf(OpaqueAction)){
			"".println();
			("this is a opaqueaction node: " + node.name).println();
			//find the module that stores the node
			//'get' method can only take one parameter, not a set
			
			var mod = nodeModuleMap.get(nodeModuleMap.keySet().selectOne(t|t.nd = node));
			for(oe in getAllEdgesFromNode(act,node)){
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
				"maps:".println();maps.println();
				toBeVisitedNodes.add(oe.target);
				"".println();
				("node "+ oe.target.name + "is added to toBeVisitedNodes at line 401").println();
			}
			visitedNodes.add(node);
			"".println();
			("toBeVisitedNodes: "+toBeVisitedNodes).println();
			
			"".println();
			("visitedNodes: "+visitedNodes).println();
		} else if(node.instanceOf(ForkNode)){
			"".println();
			("this is a Fork node: " + node.name).println();
			var mod = nodeModuleMap.get(nodeModuleMap.keySet().selectOne(t|t.nd = node));
			var isFirst = true;
			for(oe in getAllEdgesFromNode(act,node).sortEdgeByName()){
				if(isFirst){
					nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
					addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
					"maps:".println();maps.println();
					isFirst = false;
				} else {
					var newmod = mkModuleDef(mkModuleName(act,node,oe), Sequence{}, Sequence{});
					("at line 418: A new module is created for the fork node: "+ node.name  + "modname: " +newmod.name).println();
					m.modules.add(newmod);
					("Currently, m.modules =  " +m.modules).println();
					var pc = mkVarDecl(newmod, -1, null, "INACTIVE");
					newmod.vars.add(pc);
					
					//create the constant for the fork node module
					var const_nxt = mkConst(newmod.name + "::" + oe.target.name, 0);
					
					//create sync command, e.g.,
					// [DigitalCamera::F1](DigitalCamera::F1::E3::pc= INACTIVE) &(!DigitalCamera::to_be_terminated) -> (DigitalCamera::F1::E3::pc'=DigitalCamera::F1::E3::DetLight);				
					var action = mkSyncAction(act, node.name);
					
					var grd = new PRISM!AndBoolExpr;
					grd = mkAndBoolExpr(mkEqBoolExpr(pc, INACTIVE), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
					
					var updates = Set{};
					if(oe.target.instanceOf(ActivityFinalNode)){
						
						var mod_toBeTerminated = mkBoolVarDecl(newmod.name+"::to_be_terminated", false);
				
						("mod_toBeTerminated is created as "+mod_toBeTerminated).println();
			   
						//update the expression of the fomula 'toBeTerminated.expr' using the local 'toBeTerminated'
						if(toBeTerminatedIsUpdated){
							toBeTerminated.expr = mkOrBoolExpr(toBeTerminated.expr, mod_toBeTerminated);
						} else {
							toBeTerminated.expr = new PRISM!VarExpr;
							toBeTerminated.expr = mkVarExpr(mod_toBeTerminated.name);
							toBeTerminatedIsUpdated = true;
						} 
			
						updates.add(mkUpdate(pc, const_nxt, mod_toBeTerminated, true)); 
						delete mod_toBeTerminated;
						
					} else {
						updates.add(mkUpdate(pc, const_nxt));	
					}
						
					newmod.commands.add(mkCommand(action, grd, updates));
											
													
					nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, newmod);
					addMap(maps, Tuple {nd = oe.target, edg = oe}, newmod);
					"maps:".println();maps.println();
					delete const_nxt;//this constant is deleted, because it will be created again in the transformation section.
				}
				toBeVisitedNodes.add(oe.target);
				"".println();
				("node "+ oe.target.name + "is added to toBeVisitedNodes at line 439").println();
			}
			visitedNodes.add(node);

			"".println();
			("toBeVisitedNodes: "+toBeVisitedNodes).println();
			
			"".println();
			("visitedNodes: "+visitedNodes).println();
			
			
		} else if(node.instanceOf(JoinNode) and (not visitedNodes.includes(node))){
			("This is a join node: "  + node.name).println();
		//to check if the source node to the first edge to the join node has been processed
		// if yes, then path continues
		//else, do noting ,wait source node to the first edge to be processed
		//that is for join node, the path always continue for the first incoming edge
		//The FIRST is determined by the names of the edges using sortBy(c | c.name)
		
			var ie = getAllEdgesToNode(act, node).sortEdgeByName().at(0);
			("DEBUG JOIN NODE: ies = "+ getAllEdgesToNode(act, node).sortEdgeByName()).println();
			("DEBUG JOIN NODE: ie.at(0) = "+ie.name).println();
			var mod = nodeModuleMap.get(nodeModuleMap.keySet().selectOne(t|t.nd = ie.source));
			if(not (mod.isDefined())){//"not (mod.isDefined()" means that the first incoming edge of this join node is not processed yet, we need to wait the first incoming t o be processed. Now we do nothing.
			
				toBeVisitedNodes.add(node);
				"".println();
				("node "+ oe.target.name + "is added to toBeVisitedNodes at line 464").println();
				"".println();"The first incoming edge of this join node is not processed yet".println();
			} else {
				var oe = getAllEdgesFromNode(act,node).at(0);
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
				"maps:".println();maps.println();
				toBeVisitedNodes.add(oe.target);
				"".println();
				("node "+ oe.target.name + "is added to toBeVisitedNodes at line 473").println();
				visitedNodes.add(node);
				toBeVisitedNodes.remove(node);//TO DO: update algorithm in overleaf
			}
		
		
		
		//The following code WORKS as an alternative solution, the strategy is to check if the node has been visited
		// if not, then the path continues
		//else do nothing
		/*
					"".println();
			("this is a join node: "  + node.name).println();
			var mod = nodeModuleMap.get(nodeModuleMap.keySet.selectOne(t|t.nd = node));
			if(not visitedNodes.includes(node)){
				var oe = getAllEdgesFromNode(act,node).at(0);
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
				"maps:".println();maps.println();
				toBeVisitedNodes.add(oe.target);
				visitedNodes.add(node);
				//("visitedNodes"+visitedNodes).println();
				
				"".println();
			("toBeVisitedNodes: "+toBeVisitedNodes).println();
			
				"".println();
			("visitedNodes: "+visitedNodes).println();
			}
		*/
		} else if(node.instanceOf(DecisionNode)){
					"".println();
			("this is a decision node: " + node.name).println();
			var mod = nodeModuleMap.get(nodeModuleMap.keySet().selectOne(t|t.nd = node));
			for(oe in getAllEdgesFromNode(act,node).sortEdgeByName()){
				("at line 509 oe: "+oe.name).println();
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
				"maps:".println();maps.println();
				toBeVisitedNodes.add(oe.target);
				"".println();
				("node "+ oe.target.name + "is added to toBeVisitedNodes at line 511").println();
			}
			visitedNodes.add(node);
			
			"".println();
			("toBeVisitedNodes: "+toBeVisitedNodes).println();
			
			"".println();
			("visitedNodes: "+visitedNodes).println();
			
			
		} else if(node.instanceOf(MergeNode) and (not visitedNodes.includes(node))){ 
			"".println();
			("this is a merge node:" + node.name).println();
			var all_source_vistied = true; //this should be checked using nodeModuleMap, if the incoming edge exists in nodeModuleMap, then it is "visited"
			var new_module_needed = false;
			//var in_same_module = true;
			
			var ies = getAllEdgesToNode(act,node); 
			for(i in ies){
				("i.name: " +i.name).println();
				//"nodeModuleMap.get(nodeModuleMap.keySet.selectOne(t|t.edg = i)):".println();
				
				if(nodeModuleMap.get(nodeModuleMap.keySet().selectOne(t|t.edg = i)).isDefined() ){
					all_source_vistied = all_source_vistied and true;
					"the map that contains the incoming edge is defined: ".println();
					nodeModuleMap.get(nodeModuleMap.keySet().selectOne(t|t.edg = i)).name.println();}
				else {
					all_source_vistied = all_source_vistied and false;
					"map that contains the incoming edge is not defined, need to wait.".println();
				}
			}
			
			("all_source_vistied = " +all_source_vistied).println();
			
			//allocated_mods represents the existing modules that contain this merge node, 
			//but it is possible that at this moment, some incoming edges of this merge have not been added into the MAP
			var allocated_mods = new Set;
			for(k in nodeModuleMap.keySet()){
				if(k.nd = node){
				allocated_mods.add(nodeModuleMap.get(k));
				}
			}
			
			"".println();
			("allocated_mods: "+allocated_mods).println();
			
			"".println();
			("allocated_mods.size: "+allocated_mods.size()).println();
			//"===========".println();
			//var allocated_mods = nodeModuleMap.get(nodeModuleMap.keySet.selectOne(t|t.nd = node));
		
			
			//the incoming edged of the node are from different moduels, a new module for this merge node is needed
			//it is possible that at this point some incoming edges have not be processed in any moduel yet 
			if(allocated_mods.size()>1){
				new_module_needed = true;
				//in_same_module = false;
				
			} else {
				//2 CASES:
				//a. in_same_module = true, i.e.,allocated_mods.size() = 1 and all_source_vistied
				//b. all_source_vistied = false, so can not decide if new module is needed (module.size = 1, but not all incoming edges are in this module, we need to wait either the moudle.size will increase, or all the incoming edges have been processed)
				new_module_needed = false;
			}
		
			
			
			if(new_module_needed ){
			
			"".println();
			"a new_module_needed needed so the creation is processed".println();
				var oe = getAllEdgesFromNode(act,node).at(0);
				var newmod = mkModuleDef(mkModuleName(act,node), Sequence{}, Sequence{});
				("at line 585: A new module is created for the merge node: "+ node.name  + "modname: " +newmod.name).println();
				m.modules.add(newmod);
				("Currently, m.modules =  " +m.modules).println();
				var pc = mkVarDecl(newmod, -1, null, "INACTIVE");
				newmod.vars.add(pc);

				var const_nxt = mkConst(newmod.name + "::" + oe.target.name, 0);
				
				//for each incoming edge, create a command
				//E.G.,
				//[DigitalCamera::M3::E15](DigitalCamera::M3::pc= INACTIVE) & (!DigitalCamera::to_be_terminated) -> (DigitalCamera::M3::pc'=DigitalCamera::M3::TakePicture);
	//[DigitalCamera::M3::E16](DigitalCamera::M3::pc= INACTIVE) & (!DigitalCamera::to_be_terminated) -> (DigitalCamera::M3::pc'=DigitalCamera::M3::TakePicture);
				for(ie in getAllEdgesToNode(act,node)){
				
					var action = mkSyncAction(act, node.name +"::" + ie.name);
					
					var grd = new PRISM!AndBoolExpr;
					grd = mkAndBoolExpr(mkEqBoolExpr(pc, INACTIVE), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
					
					var updates = Set{};
					if(oe.target.instanceOf(ActivityFinalNode)){
					
						var mod_toBeTerminated = mkBoolVarDecl(newmod.name+"::to_be_terminated", false);
				
						("mod_toBeTerminated is created as "+mod_toBeTerminated).println();
			   
						//update the expression of the fomula 'toBeTerminated.expr' using the local 'toBeTerminated'
						if(toBeTerminatedIsUpdated){
							toBeTerminated.expr = mkOrBoolExpr(toBeTerminated.expr, mod_toBeTerminated);
						} else {
							toBeTerminated.expr = new PRISM!VarExpr;
							toBeTerminated.expr = mkVarExpr(mod_toBeTerminated.name);
							toBeTerminatedIsUpdated = true;
						} 
			
						updates.add(mkUpdate(pc, const_nxt, mod_toBeTerminated, true)); 
						delete mod_toBeTerminated;
						
					} else {
						updates.add(mkUpdate(pc, const_nxt));	
					}
						
					newmod.commands.add(mkCommand(action, grd, updates));
									
				}
				delete const_nxt;//because the const for the module will be generated again later in the transformation section
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, newmod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, newmod);
				"maps:".println();maps.println();
				toBeVisitedNodes.add(oe.target);
				"".println();
				("node "+ oe.target.name + "is added to toBeVisitedNodes at line 612").println();
				
				toBeVisitedNodes.remove(node);//TO DO: update algorithm in overleaf
				visitedNodes.add(node);
				
				
				"".println();
				("toBeVisitedNodes: "+toBeVisitedNodes).println();
			
				"".println();
				("visitedNodes: "+visitedNodes).println();
				
				
			} else if(all_source_vistied and (not new_module_needed)){// continue the path within the same module
				"".println();
				"all_source_vistied and (not new_module_needed) at line 654.".println();
				
				var oe = getAllEdgesFromNode(act,node).at(0);
				var existingmod = allocated_mods.at(0);
				
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, existingmod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, existingmod);
				"maps:".println();maps.println();
				
				toBeVisitedNodes.add(oe.target);
				"".println();
				("node "+ oe.target.name + "is added to toBeVisitedNodes at line 633").println();
				
				toBeVisitedNodes.remove(node);//TO DO: update algorithm in overleaf
				visitedNodes.add(node);
				
				"".println();
				("toBeVisitedNodes: "+toBeVisitedNodes).println();
			
				"".println();
				("visitedNodes: "+visitedNodes).println();
			
			} 
				//("FOR MERGE NODE WHEN NOT ALL INCOMING EDGES ARE VISITED, toBeVisitedNodes.size() = "+toBeVisitedNodes.size()).println();
				//all_source_vistied == false, new_module_needed == false
			else{	
			if(toBeVisitedNodes.size()=0){
				"toBeVisitedNodes.size()=0".println();
				("the current merge node is "+ node.name).println();
				"The ALGORITHM FOR DUMMY MODULE/ LOOP OF DECISION AND MERGE in traversed operation IS EXECUTED".println();
					var oe = getAllEdgesFromNode(act,node).at(0);
					var newmod = mkModuleDef(mkModuleName(act,node,oe), Sequence{}, Sequence{});
					("at line 770: A new module is created for the merge node for dummy? "+ node.name + " modname: " +newmod.name).println();
					("newmod.name = " + newmod.name).println();
					//TO DO: I am not sure whether the follow line is needed
					m.modules.add(newmod);
					("Currently, m.modules =  " +m.modules).println();
					var pc = mkVarDecl(newmod, -1, null, "INACTIVE");
					newmod.vars.add(pc);
				
					for(ie in getAllEdgesToNode(act,node)){
						var const_nxt = mkConst(newmod.name + "::" + oe.target.name, 0);//the value of const_nxt does not matter as we only need the name
						
						
						var action = mkSyncAction(act, node.name +"::" + ie.name);
					
						var grd = new PRISM!AndBoolExpr;
						grd = mkAndBoolExpr(mkEqBoolExpr(pc, INACTIVE), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
						
						var updates = Set{};
						if(oe.target.instanceOf(ActivityFinalNode)){
							
							
							
							var mod_toBeTerminated = mkBoolVarDecl(newmod.name+"::to_be_terminated", false);
				
							("mod_toBeTerminated is created as "+mod_toBeTerminated).println();
			   
							//update the expression of the fomula 'toBeTerminated.expr' using the local 'toBeTerminated'
							if(toBeTerminatedIsUpdated){
								toBeTerminated.expr = mkOrBoolExpr(toBeTerminated.expr, mod_toBeTerminated);
							} else {
								toBeTerminated.expr = new PRISM!VarExpr;
								toBeTerminated.expr = mkVarExpr(mod_toBeTerminated.name);
								toBeTerminatedIsUpdated = true;
							} 
			
							updates.add(mkUpdate(pc, const_nxt, mod_toBeTerminated, true)); 
							delete mod_toBeTerminated;
							
							
						} else {
							updates.add(mkUpdate(pc, const_nxt));	
						}
							
						newmod.commands.add(mkCommand(action, grd, updates));
						
						
						delete const_nxt;
					}
					nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, newmod);
					addMap(maps, Tuple {nd = oe.target, edg = oe}, newmod);
					"maps:".println();maps.println();
					//???TO DO: only one key in tuple, what is the value of edg?
					
					
					addMap(dummyNodeModuleSeq, node, newmod);
					
					toBeVisitedNodes.add(oe.target);
					"".println();
					("node "+ oe.target.name + "is added to toBeVisitedNodes at line 668").println();
					visitedNodes.add(node);
					
					"".println();
					("toBeVisitedNodes: "+toBeVisitedNodes).println();
			
					"".println();
					("visitedNodes: "+visitedNodes).println();
				} else // there might be multiple loops, progress_made set to false when first time that only merge node left in toBeVisitedNodes
				if(toBeVisitedNodes.select(n|n.instanceOf(MergeNode)).size()>0 and toBeVisitedNodes.select(n|not n.instanceOf(MergeNode)).size()=0 and progress_made.isEmpty()){
					("toBeVisitedNodes = "+toBeVisitedNodes).println();
					"Only merge left, and there are more than one merge, so set progress_made as true for all merge nodes at line 806, this is the first time that only merge node left".println();
					for(n in toBeVisitedNodes.select(n|n.instanceOf(MergeNode))){
						progress_made.put(n,true);
					}
					progress_made.put(node,true);
					toBeVisitedNodes.add(node);
					continue;
				}else if(toBeVisitedNodes.select(n|n.instanceOf(MergeNode)).size()>0 and toBeVisitedNodes.select(n | not n.instanceOf(MergeNode)).size() = 0 and progress_made.get(node)){// if there is node with progress_made this is the second time meeting this merge node when only merge nodes left in toBeVisited
					"if the node is progress_made, this is the second time meeting this merge node when only merge nodes left in toBeVisited, so we set the node to progress_made as false at line 812".println();
					progress_made.remove(node);
					progress_made.put(node,false);
					toBeVisitedNodes.add(node);
				}else if (toBeVisitedNodes.select(n|n.instanceOf(MergeNode)).size()>0 and toBeVisitedNodes.select(n | not n.instanceOf(MergeNode)).size() = 0 and  progress_made.values().asSet().size()=1 and progress_made.values().asSet().at(0)= false) {
				"this is when all merge nodes are making no progress, then a dummy module should be made for this merge node at line 818".println();
				"The ALGORITHM FOR DUMMY MODULE/ LOOP OF DECISION AND MERGE in traversed operation IS EXECUTED for multiple loops".println();
					var oe = getAllEdgesFromNode(act,node).at(0);
					var newmod = mkModuleDef(mkModuleName(act,node,oe), Sequence{}, Sequence{});
					("at line 817: A new module is created for the merge node for dummy? "+ node.name + "modname: " +newmod.name).println();
					//TO DO: I am not sure whether the follow line is needed
					m.modules.add(newmod);
					("Currently, m.modules =  " +m.modules).println();
					var pc = mkVarDecl(newmod, -1, null, "INACTIVE");
					newmod.vars.add(pc);
					
					for(ie in getAllEdgesToNode(act,node)){
						var const_nxt = mkConst(newmod.name + "::" + oe.target.name, 0);//the value of const_nxt does not matter as this constand will be deleted and recreated in the transformation section
						
						
						var action = mkSyncAction(act, node.name +"::" + ie.name);
					
						var grd = new PRISM!AndBoolExpr;
						grd = mkAndBoolExpr(mkEqBoolExpr(pc, INACTIVE), mkNotBoolExpr(mkVarExpr(toBeTerminated.name)));
						
						var updates = Set{};
						if(oe.target.instanceOf(ActivityFinalNode)){
							
							var mod_toBeTerminated = mkBoolVarDecl(newmod.name+"::to_be_terminated", false);
				
							("mod_toBeTerminated is created as "+mod_toBeTerminated).println();
			   
							//update the expression of the fomula 'toBeTerminated.expr' using the local 'toBeTerminated'
							if(toBeTerminatedIsUpdated){
								toBeTerminated.expr = mkOrBoolExpr(toBeTerminated.expr, mod_toBeTerminated);
							} else {
								toBeTerminated.expr = new PRISM!VarExpr;
								toBeTerminated.expr = mkVarExpr(mod_toBeTerminated.name);
								toBeTerminatedIsUpdated = true;
							} 
			
							updates.add(mkUpdate(pc, const_nxt, mod_toBeTerminated, true)); 
							delete mod_toBeTerminated;
							
							
						} else {
							updates.add(mkUpdate(pc, const_nxt));	
						}
							
						newmod.commands.add(mkCommand(action, grd, updates));
						
						
						delete const_nxt;
					}
					nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, newmod);
					addMap(maps, Tuple {nd = oe.target, edg = oe}, newmod);
					"maps:".println();maps.println();
					
										
					addMap(dummyNodeModuleSeq, node, newmod);
					toBeVisitedNodes.add(oe.target);
					"".println();
					("node "+ oe.target.name + "is added to toBeVisitedNodes at line 668").println();
					visitedNodes.add(node);
					
					"".println();
					("toBeVisitedNodes: "+toBeVisitedNodes).println();
			
					"".println();
					("visitedNodes: "+visitedNodes).println();
					
					//to clear the map because 
					progress_made.clear();
					
				}
				
				
				else {
					"".println();
					"the last else in line 200 is processed".println();
					//TO DO
					// what is this situation?
					//the following line is commented out, is related to dummy, shall be added back
					//after the dummy section is complete
					
					toBeVisitedNodes.add(node);
					// visitedNodes.add(node);//?? TO DO
					"".println();
					("toBeVisitedNodes: "+toBeVisitedNodes).println();
			
					"".println();
					("visitedNodes: "+visitedNodes).println();
					
					
				}
			}
		
		

		} else if(node.instanceOf(FlowFinalNode) and (not visitedNodes.includes(node))){
					"".println();
			"this is a FlowFinalNode node".println();
			visitedNodes.add(node);
		} else if(node.instanceOf(ActivityFinalNode) and (not visitedNodes.includes(node))){
			
					"".println();
			"this is a ActivityFinalNode  node".println();
			visitedNodes.add(node);
		} else if(node.instanceOf(CallBehaviorAction)){
			traverseNodes(node.behavior, false);			
			var mod = nodeModuleMap.get(nodeModuleMap.keySet().selectOne(t|t.nd = node));
			for(oe in getAllEdgesFromNode(act,node)){
				nodeModuleMap.put(Tuple {nd = oe.target, edg = oe}, mod);
				addMap(maps, Tuple {nd = oe.target, edg = oe}, mod);
				"maps:".println();maps.println();
				toBeVisitedNodes.add(oe.target);				
			}
			visitedNodes.add(node);
		} 
	}
}





/*

//e.g., [DigitalCamera::terminate] (DigitalCamera::to_be_terminated) ->(DigitalCamera::M1::pc'=INACTIVE) & (DigitalCamera::M1::to_be_terminated'=false)
//mod.commands.add(mkCommand(act, "terminate", toBeTerminated.expr, updates))
operation mkCommand(
	act: AD!Activity,  //activity
	action: String,
	grd: PRISM!BoolExpr,
	updates: PRISM!updates): PRISM!Command{
	var cmd = new PRISM!Command;
	cmd.action = mkAction(act,action); 
	cmd.grd = grd;
	cmd.updates = updates;
	
	return cmd;
}


//mkCommand(act, mod, "terminate", mod.vars.at(0), toBeTerminated, terminated,terminated, true)
//used for termination in main module: to set terminated = true
//e.g., [DigitalCamera::terminate] (DigitalCamera::to_be_terminated) & (!DigitalCamera::terminated)->(DigitalCamera::terminated'=true);
operation mkCommand(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!VarDecl,  //first guard
	g2: PRISM!VarDecl,   //second guard
	update_var: PRISM!VarDecl, //update var
	update_value: Boolean  //update value
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(act,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuardFor2VarWithRightNeg(g1, g2);
	//TO DO
	cmd.updates.add(mkUpdate(update_var,update_value));
	return cmd;

}



//mkCommand(act, mod, "", mod.vars.at(0), toBeTerminated, terminated,  toBeTerminated, false, mod.vars.at(0), INACTIVE);
//used for the command in main module: to set to_be_terminated = false
//e.g.,[](DigitalCamera::terminated)&(DigitalCamera::to_be_terminated) ->(DigitalCamera::to_be_terminated'=false)& DigitalCamera::I0::E0::pc'=INACTIVE);
operation mkCommand(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!VarDecl,  //first guard
	g2: PRISM!VarDecl,   //second guard
	update_var: PRISM!VarDecl, //update var_1
	update_value: Boolean,  //update value_1
	update_var_2: PRISM!VarDecl, //update var_2
	update_value_2: PRISM!Constant  //update value_2
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(act,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuardForTwoVar(g1, g2);
	
	cmd.updates.add(mkUpdate(update_var,update_value));
	cmd.updates.add(mkUpdate(update_var_2,update_value_2));
	
	return cmd;

}



operation mkCommand(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!VarDecl,  //first guard
	g2: PRISM!VarDecl,   //second guard
	updates: Set
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(act,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuardForTwoVar(g1, g2);
	
	cmd.updates = updates;
	
	return cmd;

}


//the action is used for synchronization, the action method 'mkAction' has two parameter: ACT and NODE, e.g., [digitalcamera::F1] 
operation mkCommandSyncAct(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!Constant,  //first guard
	g2: PRISM!VarDecl,   //second guard
	const: PRISM!Constant  //update 
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(act,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuard(pc, g1, g2);
	//TO DO
	cmd.updates.add(mkUpdate(pc,const));
	return cmd;

}



//e.g., [DigitalCamera::terminate] (DigitalCamera::to_be_terminated) -> (DigitalCamera::F1::E3::pc'=INACTIVE);
//mkCommandSyncAct(act, mod, "terminate", toBeTerminated, updates)
//has ONLY ONE GUARD: to_be_terminated
operation mkCommandSyncAct(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	g: PRISM!VarDecl,   // guard= toBeTerminated
	updates: Set  //updates
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(act,node_or_edg_name); 
	}
	cmd.grd = mkGuard(g);
	//TO DO
	cmd.updates = updates;
	return cmd;
}


//mkCommandSyncAct(act, newmod, ie.name, pc, INACTIVE, to_be_terminated, updates)
operation mkCommandSyncAct(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!Constant,  //first guard pc= INACTIVE
	g2: PRISM!VarDecl,   //second guard to_be_terminated
	updates: Set  //updates
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(act,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuard(pc, g1, g2);
	//TO DO
	cmd.updates = updates;
	return cmd;
}





//the action method 'mkAction' has 2 parameters: MODULE and NODE, e.g., [digitalcamera::I0::E0::TurnOn] 
operation mkCommand(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!Constant,  //first guard
	g2: PRISM!VarDecl,   //second guard
	const: PRISM!Constant  //update 
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(module,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuard(pc, g1, g2);
	//TO DO
	cmd.updates.add(mkUpdate(pc,const));
	return cmd;

}



//the action method 'mkAction' has 2 parameters: MODULE and NODE, e.g., [digitalcamera::I0::E0::TurnOn] 
operation mkCommand(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc = mod.vars.at(0)
	g1: PRISM!Constant,  //first guard
	g2: PRISM!VarDecl,   //second guard
	updates: Set  //set of update
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(module,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuard(pc, g1, g2);
	
	cmd.updates = updates;
	return cmd;

}



//for Decision node with guard, without probability
//mkCommandforDecisionNdWithGrd(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, grd, const_nxt)
//mkCommand(act, mod, node.name, mod.vars.at(0), const, toBeTerminated, grd, const_nxt)
//grd = edge.guard
//the action method 'mkAction' has 2 parameters: MODULE and NODE, e.g., [digitalcamera::I0::E0::TurnOn] 
operation mkCommandforDecisionNdWithGrd(
	act: AD!Activity,  //activity
	module: PRISM!ModuleDef,  //module
	node_or_edg_name: String,  //action
	pc: PRISM!VarDecl,  //pc
	g1: PRISM!Constant,  //first guard
	g2: PRISM!VarDecl,   //second guard = not to_be_terminated
	edge_grd:  PRISM!VarDecl, //3rd guard = edge guard
	const: PRISM!Constant  //update 
	): PRISM!Command {
	
	var cmd = new PRISM!Command;
	if(not (node_or_edg_name = "")){
		cmd.action = mkAction(module,node_or_edg_name); 
	}
	cmd.grd = mkAndBoolGuardForThreeVar(pc, g1, g2, edge_grd);
	//TO DO
	cmd.updates.add(mkUpdate(pc,const));
	return cmd;

}











*/








/*
//for main module termination command
//(DigitalCamera::terminated'=true)
//to assign a bool to a var
operation mkUpdate (
	update_var: PRISM!VarDecl, 
	update_value: Boolean
	): PRISM!Update {
	
	var update = new PRISM!Update;
	//update.probability = 1;
	
	update.assigns.add(mkAssignment(update_var, update_value));	
	
	return update;

}

*/


/*
//value_expr = mkNotBoolExpr(getAllEdgesFromNode(act,dn).excluding(oe).at(0).`guard`.value);
operation mkNotBoolExpr(grd_name: String): PRISM!NotBoolExpr{
 	var notExpr = new PRISM!NotBoolExpr;
	notExpr.value = new PRISM!VarExpr;
	notExpr.value.name = grd_name;
	
	return notExpr;

}
*/







/*
//e.g., (pc = g1) & (!g2)
//left: pc == g1
//right: ! g2
//TO DO: how to code optimization to remove notBoolExpr in the operation, and show it as a paramter
 
operation mkAndBoolGuard(
	pc: PRISM!VarDecl, 
	g1 : PRISM!Constant, 
	g2 : PRISM!VarDecl) : PRISM!BoolExpr {
	
	var grd = new PRISM!AndBoolExpr; 
	
	grd.left = new PRISM!EqBoolExpr;
	grd.left.left = new PRISM!VarExpr;	
	grd.left.left.name = pc.name;
	grd.left.right = new PRISM!VarExpr;
	grd.left.right.name = g1.name;
		
	grd.right = new PRISM!NotBoolExpr;
	grd.right.value = new PRISM!VarExpr;
	grd.right.value.name = g2.name;
	
	return grd;
}



//left = varDecl of Boolean type, right = varDecl of Boolean type
//e.g., (DigitalCamera::to_be_terminated) & (!DigitalCamera::terminated)
operation mkAndBoolGuardFor2VarWithRightNeg(
	g1 : PRISM!VarDecl, 
	g2 : PRISM!VarDecl) : PRISM!BoolExpr {
	
	var grd = new PRISM!AndBoolExpr; 
	
	grd.left = new PRISM!VarExpr;
	grd.left.name = g1.name;
		
	grd.right = new PRISM!NotBoolExpr;
	grd.right.value = new PRISM!VarExpr;
	grd.right.value.name = g2.name;

	
	return grd;
}






//left = varDecl of Boolean type, right = varDecl of Boolean type
//e.g., (DigitalCamera::to_be_terminated) & (DigitalCamera::terminated)
operation mkAndBoolGuardForTwoVar(
	g1 : PRISM!VarDecl, 
	g2 : PRISM!VarDecl) : PRISM!BoolExpr {
	
	var grd = new PRISM!AndBoolExpr; 
	
	grd.left = new PRISM!VarExpr;
	grd.left.name = g1.name;
		
	grd.right = new PRISM!VarExpr;
	grd.right.name = g2.name;

	
	return grd;
}

//to create the guard for Decision Node with guard, 
//[Digital_Camera::F1::E4::D3]   (pc = D3)  &  (!to_be_terminated) & charged      ->     pc' = M2
// g3 = charged
//charged is a global var
operation mkAndBoolGuardForThreeVar(
	pc: PRISM!VarDecl, 
	g1 : PRISM!Constant,
	g2 : PRISM!VarDecl,
	g3 : PRISM!VarDecl
	) : PRISM!BoolExpr {
	
	var grd = new PRISM!AndBoolExpr; 
	
	grd.left = new PRISM!EqBoolExpr;
	grd.left.left = new PRISM!VarExpr;	
	grd.left.left.name = pc.name;
	grd.left.right = new PRISM!VarExpr;
	grd.left.right.name = g1.name;
		
			
	grd.right = new PRISM!AndBoolExpr; 
	grd.right.left = new PRISM!NotBoolExpr;
	grd.right.left.value = new PRISM!VarExpr;
	grd.right.left.value.name = g2.name;
	
	
	grd.right.right = new PRISM!VarExpr;
	grd.right.right.name = g3.name;

	
	return grd;
}

*/

//guard is type of Boolexpr, so operation for mkBoolExpr is sufficient 
/*
//mkGuard(g): to convert a var into a guard (boolExpr)
//e.g., in this command: [DigitalCamera::terminate](DigitalCamera::to_be_terminated) -> (DigitalCamera::F1::E3::pc'=INACTIVE);
operation mkGuard(g:PRISM!VarDecl) : PRISM!BoolExpr {
	
	var grd = new PRISM!VarExpr; 
	grd.name = g.name;
	
	return grd;
}





//grd = mkGuard(toBeTerminated, true);
//grd = (toBeTerminated)
operation mkGuard(g:PRISM!Formula) : PRISM!BoolExpr {
	
	var grd = new PRISM!BoolExpr; 
	grd = g.expr;
	
	return grd;
}

*/




/*
//replaced by mkBoolVarDecl in prism.eol
operation mkBoolVarDecl(
	act: AD!Activity,
	name: String,
	init_value: String) : PRISM!VarDecl
{
	var v = new PRISM!VarDecl;
	v.name = act.name + "::" + name;
	v.type = new PRISM!BoolType;
	v.init = mkVarExpr(init_value);
	return v;
}

operation mkBoolVarDecl(
	mod: AD!ModuleDef,
	name: String,
	init_value: String) : PRISM!VarDecl
{
	var v = new PRISM!VarDecl;
	v.name = mod.name + "::" + name;
	v.type = new PRISM!BoolType;
	v.init = mkVarExpr(init_value);
	return v;
}

*/





 	






 	




 	
 